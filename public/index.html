<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>呆呆</title>
  <meta name="author" content="BetaRabbit">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="呆呆"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="呆呆" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">呆呆</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-06-10T15:09:45.000Z"><a href="/2013/06/10/ie下点击scrollbar会触发input元素的blur事件/">6月 10 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/06/10/ie下点击scrollbar会触发input元素的blur事件/">IE下点击scrollbar会导致焦点移动到body</a></h1>
  

    </header>
    <div class="entry">
      
        <h2>现象</h2>
<p>IE这货果然与众不同，当光标焦点在input时，点击同页面内其他区域的scrollbar，会导致焦点移动到body，从而触发绑定在input上的blur事件，如果input中的值与之前不同，甚至还会触发change事件...
Chrome曾经也有类似的问题，但在最新版中已经修正了，而Firefox则完全没有这样的问题。</p>
<h2>影响</h2>
<p>这个问题看起来微不足道，实际上影响还是非常大的，主要表现在下面2个方面</p>
<ul>
<li><p>多数的suggest控件会出错
<br>
suggest往往是通过input(输入部分)和div(下拉框部分)组成。有时，下拉框内容过多，用户需要移动滚动条才能看全选项，但因为点击滚动条会让input失去焦点，导致控件误认为用户结束输入，从而关闭suggest的下拉部分，导致用户实际上无法正确的进行滚动条操作。</p>
</li>
<li><p>form
<br>
这个更容易理解了，一般来说form的验证都是绑定在blur或者change事件上，如果form太长，需要移动滚动条才能看全的情况下，一旦鼠标点击滚动条就会错误的触发form验证操作，将无用的错误信息显示给用户。</p>
</li>
</ul>
<h2>解决方案</h2>
<p>我们来看看jQueryUI的Autocomplete是怎么解决这个问题的。</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="comment">// input's blur event</span>
blur: <span class="keyword">function</span>( event ) {
    <span class="keyword">if</span> ( <span class="keyword">this</span>.cancelBlur ) {
        <span class="keyword">delete</span> <span class="keyword">this</span>.cancelBlur;
        <span class="keyword">return</span>;
    }

    clearTimeout( <span class="keyword">this</span>.searching );
    <span class="keyword">this</span>.close( event );
    <span class="keyword">this</span>._change( event );
}

<span class="comment">// dropdown's mousedown event</span>
mousedown: <span class="keyword">function</span>( event ) {
    <span class="comment">// prevent moving focus out of the text field</span>
    event.preventDefault();

    <span class="comment">// IE doesn't prevent moving focus even with event.preventDefault()</span>
    <span class="comment">// so we set a flag to know when we should ignore the blur event</span>
    <span class="keyword">this</span>.cancelBlur = <span class="literal">true</span>;
    <span class="keyword">this</span>._delay(<span class="keyword">function</span>() {
        <span class="keyword">delete</span> <span class="keyword">this</span>.cancelBlur;
    });

    <span class="comment">// clicking on the scrollbar causes focus to shift to the body</span>
    <span class="comment">// but we can't detect a mouseup or a click immediately afterward</span>
    <span class="comment">// so we have to track the next mousedown and close the menu if</span>
    <span class="comment">// the user clicks somewhere outside of the autocomplete</span>
    <span class="keyword">var</span> menuElement = <span class="keyword">this</span>.menu.element[ <span class="number">0</span> ];
    <span class="keyword">if</span> ( !$( event.target ).closest( <span class="string">".ui-menu-item"</span> ).length ) {
        <span class="keyword">this</span>._delay(<span class="keyword">function</span>() {
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            <span class="keyword">this</span>.document.one( <span class="string">"mousedown"</span>, <span class="keyword">function</span>( event ) {
                <span class="keyword">if</span> ( event.target !== that.element[ <span class="number">0</span> ] &amp;&amp;
                        event.target !== menuElement &amp;&amp;
                        !$.contains( menuElement, event.target ) ) {
                    that.close();
                }
            });
        });
    }
}
</pre></td></tr></table></figure>


<p>这下就很清楚了，要处理这个问题，要点有两个：</p>
<ul>
<li>通过自定义的flag判断是否需要跳过(直接return)input的blur事件</li>
<li>全局(document)监视下一次mousedown事件，如果不是特定区域才执行blur相关操作</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-06-08T19:26:47.000Z"><a href="/2013/06/09/如何将一个string和多个string值进行比较/">6月 9 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/06/09/如何将一个string和多个string值进行比较/">如何将一个String和多个String值进行比较</a></h1>
  

    </header>
    <div class="entry">
      
        <p>开发中我们经常需要将一个String和多个String值进行比较。直觉反应是使用<code>||</code>符号连接多个<code>===</code>完成，比如：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> (string === <span class="string">'banana'</span> || string === <span class="string">'pineapple'</span>) {
   fruitColor = <span class="string">'yellow'</span>;
}
</pre></td></tr></table></figure>

<p>这样能够很好的完成需求，但总觉得有点笨，并且对扩展不友好，当我们的水果种类变多时：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> (string === <span class="string">'banana'</span> || string === <span class="string">'pineapple'</span> || string === <span class="string">'mongo'</span> || string === <span class="string">'lemon'</span>) {
   fruitColor = <span class="string">'yellow'</span>;
}
</pre></td></tr></table></figure>

<p>上面的代码看起来就不那么好看了，让我们看看有什么其他方式能够处理这种需求。</p>
<h2>Switch</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">switch</span>(string) {
    <span class="keyword">case</span> <span class="string">'banana'</span>:
    <span class="keyword">case</span> <span class="string">'pineapple'</span>:
    <span class="keyword">case</span> <span class="string">'mongo'</span>:
    <span class="keyword">case</span> <span class="string">'lemon'</span>:
      fruitColor = <span class="string">'yellow'</span>;
}
</pre></td></tr></table></figure>

<p>这看起来不错，但是总是要多打些字，对于不喜欢多打字的人来说不是个好方法。</p>
<h2>Array</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ([<span class="string">'banana'</span>, <span class="string">'pineapple'</span>, <span class="string">'mongo'</span>, <span class="string">'lemon'</span>].indexOf(string) &gt;= <span class="number">0</span>) {
    fruitColor = <span class="string">'yellow'</span>;
}
</pre></td></tr></table></figure>

<p>这下好多了，但还有个问题，IE9以下的IE浏览器并不支持<code>indexOf</code>方法，如果你要在IE&lt;=8的环境中使用Array方式比较多个string值，要么自己写一个<code>indexOf</code>方法，要么就得引入一些库来做浏览器兼容。</p>
<h2>jQuery</h2>
<p>jQuery提供了一个<code>inArray</code>方法</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> ($.inArray([<span class="string">'banana'</span>, <span class="string">'pineapple'</span>, <span class="string">'mongo'</span>, <span class="string">'lemon'</span>], string) &gt;= <span class="number">0</span>) {
    fruitColor = <span class="string">'yellow'</span>;
}
</pre></td></tr></table></figure>


<h2>Underscore</h2>
<p>Underscore提供了一个<code>contains</code>方法</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> (_.contains([<span class="string">'banana'</span>, <span class="string">'pineapple'</span>, <span class="string">'mongo'</span>, <span class="string">'lemon'</span>], string)) {
    fruitColor = <span class="string">'yellow'</span>;
}
</pre></td></tr></table></figure>


<h2>正则表达式</h2>
<p>当然，我们还有终极武器——正则表达式</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> (<span class="regexp">/^(banana|pineapple|mongo|lemon)$/</span>.test(string)) {
    fruitColor = <span class="string">'yellow'</span>;
}
</pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-03-18T16:23:47.000Z"><a href="/2013/03/19/javascript-throttle--debounce/">3月 19 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/03/19/javascript-throttle--debounce/">JavaScript Throttle &amp; Debounce</a></h1>
  

    </header>
    <div class="entry">
      
        <h2>Throttle</h2>
<p>无视一定时间内所有的调用，适合在发生频度比较高的，处理比较重的时候使用。</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> <span class="params">(func, threshold, alt)</span> {</span>
    <span class="keyword">var</span> last = Date.now();
    threshold = threshold || <span class="number">100</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> now = Date.now();

        <span class="keyword">if</span> (now - last &lt; threshold) {
            <span class="keyword">if</span> (alt) {
                alt.apply(<span class="keyword">this</span>, arguments);
            }
            <span class="keyword">return</span>;
        }

        last = now;
        func.apply(<span class="keyword">this</span>, arguments);
    };
};
</pre></td></tr></table></figure>


<h2>Debounce</h2>
<p>一定间隔内没有调用时，才开始执行被调用方法</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> <span class="params">(func, threshold, execASAP)</span> {</span>
    <span class="keyword">var</span> timeout = <span class="literal">null</span>;
    threshold = threshold || <span class="number">100</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> args = arguments;
        <span class="keyword">var</span> delayed = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">if</span> (!execASAP) {
                func.apply(self, args);
            }
            timeout = <span class="literal">null</span>;
        };

        <span class="keyword">if</span> (timeout) {
            clearTimeout(timeout);
        } <span class="keyword">else</span> <span class="keyword">if</span> (execASAP) {
            func.apply(self, args);
        }

        timeout = setTimeout(delayed, threshold);
    };
};
</pre></td></tr></table></figure>


<h2>Test</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="params">(wrapper, threshold)</span> {</span>
    <span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        console.log(Date.now() - start);
    };
    <span class="keyword">var</span> wrapperedFunc = wrapper(log, threshold);
    <span class="keyword">var</span> start = Date.now();
    <span class="keyword">var</span> arr = [];

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {
        arr.push(wrapperedFunc);
    }

    <span class="keyword">while</span>(i &gt; <span class="number">0</span>) {
        <span class="keyword">var</span> random = Math.random() * <span class="number">1000</span>;
        console.log(<span class="string">'index: '</span> + i);
        console.log(<span class="string">'random: '</span> + random);
        setTimeout(arr[--i], random);
    }
};

test(debounce, <span class="number">1000</span>);
test(throttle, <span class="number">1000</span>);
</pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-11-03T16:26:45.000Z"><a href="/2012/11/04/string-primitive和string-object/">11月 4 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/11/04/string-primitive和string-object/">String Primitive和String Object</a></h1>
  

    </header>
    <div class="entry">
      
        <p>网上看到下面这段代码，很有意思。</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>String.prototype.cut = <span class="function"><span class="keyword">function</span> <span class="params">(len)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.length &gt; len ? <span class="keyword">this</span>.substring(<span class="number">0</span>, len) + <span class="string">'...'</span> : <span class="keyword">this</span>;
};

<span class="keyword">var</span> obj = [<span class="string">"Superman"</span>, <span class="string">"Batman"</span>, <span class="string">"Iron Man"</span>];
console.log(<span class="keyword">typeof</span> obj[<span class="number">1</span>].cut(<span class="number">6</span>));
console.log(obj[<span class="number">1</span>].cut(<span class="number">6</span>));
</pre></td></tr></table></figure>


<p>这段代码很简单，判断字符串的长度，如果大于给定长度（L）输出，输出字符串前L位加上“…”，否则输出字符串本身。</p>
<p>那么，上面的代码是不是和我们期待的一样输出下面的内容呢?</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="string">"String"</span>
<span class="string">"Batman"</span>
</pre></td></tr></table></figure>


<p>答案是否定的，实际的输出其实是:</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="string">"object"</span>
&lt;String Object&gt;
</pre></td></tr></table></figure>


<p>这其实是因为String对象(String Object)和String基本类型(String Primitive)的不同导致的。字符串在JavaScript中有两种存在形式:</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">new</span> String(<span class="string">'object'</span>);<span class="comment">// String Object</span>
<span class="string">'primitive'</span>;<span class="comment">// String Primitive</span>
</pre></td></tr></table></figure>


<p>String的所有实用方法其实都是在String对象的prototype上，String基本类型是没有这些方法的。</p>
<p>因此当执行<code>&#39;primitive&#39;.slice(0)</code>时，JavaScript会自动将基本类型包装成对应的对象，调用对象上的方法，完成之后自动将对象销毁。因此，最上面的cut函数中this其实已经不是String Primitive而是String Object，当我们直接返回<code>this</code>时，返回值其实是”Batman”的String Object，所以<code>typeof</code>返回<code>object</code>。</p>
<p>所以，这个cut函数正确写法应该用String转换函数将Object转为Primitive。</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>String.prototype.cut = <span class="function"><span class="keyword">function</span> <span class="params">(len)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.length &gt; len ? <span class="keyword">this</span>.substring(<span class="number">0</span>, len) + <span class="string">'...'</span> : String(<span class="keyword">this</span>);
};
</pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-08-01T18:57:06.000Z"><a href="/2012/08/02/javascript中对空string调用split返回不是空数组/">8月 2 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/08/02/javascript中对空string调用split返回不是空数组/">Javascript中对空string调用split返回不是空数组</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天在工作中发现一个诡异的问题，理论上应该是没有元素的数组，长度居然是1。查了半天，原来是Javascript中的split和其他语言中不同，即对空string使用split会返回含有一个空string的数组，而不是一个空数组。</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> str = <span class="string">""</span>,
    arr = str.split(<span class="string">"_"</span>);
 
console.log(arr.length === <span class="number">1</span>); <span class="comment">//true</span>
console.log(arr === []); <span class="comment">//false</span>
console.log(arr === [<span class="string">""</span>]); <span class="comment">//true</span>
</pre></td></tr></table></figure>


<p>参考MDN，也有类似的说明。</p>
<blockquote><p>Note: When the string is empty, split returns an array containing one empty string, rather than an empty array.</p>
</blockquote>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-01-27T20:29:55.000Z"><a href="/2012/01/28/翻译javascript-scoping-and-hoisting/">1月 28 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/01/28/翻译javascript-scoping-and-hoisting/">[翻译]JavaScript Scoping and Hoisting</a></h1>
  

    </header>
    <div class="entry">
      
        <p>原文链接：<a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting">JavaScript Scoping and Hoisting</a></p>
<p>你知道下面的JavaScript代码执行后会alert出什么值吗？</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = <span class="number">1</span>;
<span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (!foo) {
      <span class="keyword">var</span> foo = <span class="number">10</span>;
    }
    alert(foo);
}
bar();
</pre></td></tr></table></figure>


<p>如果答案是&quot;10&quot;令你感到惊讶的话，那么下面这个会让你更加困惑：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> a = <span class="number">1</span>;
<span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span> {</span>
    a = <span class="number">10</span>;
    <span class="keyword">return</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span> {</span>}
}
b();
alert(a);
</pre></td></tr></table></figure>


<p>浏览器会alert“1”。那么，到底是怎么了？尽管这看起来有点奇怪、有点危险又有点令人困惑，但这事实上却是这门语言一个强力的具有表现力的特性。我不知道是不是有个标准来定义这种行为，但是我喜欢用”hoisting”来描述。这篇文章试着去解释这种机制，但是首先，让我们对JavaScript的scoping做一些必要的了解。</p>
<h2>Scoping in JavaScript</h2>
<p>对于JavaScript新手来说scoping是最令人困惑的部分之一。事实上，不仅仅是新手，我遇到或很多有经验的JavaScript程序员也不能完全理解scoping。JavaScript的scoping如此复杂的原因是它看上去非常像C系语言的成员。请看下面的C程序：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">#include &lt;stdio.h&gt;</span>
<span class="keyword">int</span> main() {
    <span class="keyword">int</span> <span class="keyword">x</span> = <span class="number">1</span>;
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>, "</span>, <span class="keyword">x</span>); <span class="regexp">//</span> <span class="number">1</span>
    <span class="keyword">if</span> (<span class="number">1</span>) {
        <span class="keyword">int</span> <span class="keyword">x</span> = <span class="number">2</span>;
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>, "</span>, <span class="keyword">x</span>); <span class="regexp">//</span> <span class="number">2</span>
    }
    <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>\n"</span>, <span class="keyword">x</span>); <span class="regexp">//</span> <span class="number">1</span>
}
</pre></td></tr></table></figure>


<p>这段程序的输出是1,2,1。这是因为在C系语言有块级作用域(block-level scope),当进入到一个块时，就像if语句，在这个块级作用域中会声明新的变量，这些变量不会影响到外部作用域。但是JavaScript却不是这样。在Firebug中试试下面的代码：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> x = <span class="number">1</span>;
console.log(x); <span class="comment">// 1</span>
<span class="keyword">if</span> (<span class="literal">true</span>) {
    <span class="keyword">var</span> x = <span class="number">2</span>;
    console.log(x); <span class="comment">// 2</span>
}
console.log(x);<span class="comment">// 2</span>
</pre></td></tr></table></figure>


<p>在这段代码中，Firebug显示1，2,2。这是因为JavaScript是函数级作用域(function-level scope)。这和C系语言是完全不同的。块，就像if语句，并不会创建一个新的作用域。只有函数才会创建新的作用域。</p>
<p>对于大部分熟悉C，C++，C#或是Java的程序员来说，这是意料之外并且不被待见的。幸运的是，因为JavaScript函数的灵活性，对于这个问题我们有一个解决方案。如果你必须在函数中创建一个临时的作用域，请像下面这样做：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> x = <span class="number">1</span>;
    <span class="keyword">if</span> (x) {
        (<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            <span class="keyword">var</span> x = <span class="number">2</span>;
            <span class="comment">// some other code</span>
        }());
    }
    <span class="comment">// x is still 1.</span>
}
</pre></td></tr></table></figure>


<p>这种方面确实非常灵活，它使用在任何需要创建一个临时作用域的地方，不仅仅是某个块中。但是，我强烈建议你花点时间好好理解下JavaScript scoping。它实在是非常强力，而且它也是我最喜欢的语言特性之一。如果你很好的理解了scoping，理解hoisting将会更加容易。</p>
<h2>Declarations, Names, and Hoisting</h2>
<p>在JavaScript中，一个作用域(scope)中的名称(name)有以下四种：
1. 语言自身定义(Language-defined): 所有的作用域默认都会包含this和arguments。
2. 函数形参(Formal parameters): 函数有名字的形参会进入到函数体的作用域中。
3. 函数声明(Function decalrations): 通过function foo() {}的形式。
4. 变量声明(Variable declarations): 通过var foo;的形式。</p>
<p>函数声明和变量声明总是被JavaScript解释器隐式地提升(hoist)到包含他们的作用域的最顶端。很明显的，语言自身定义和函数形参已经处于作用域顶端。这就像下面的代码：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    bar();
    <span class="keyword">var</span> x = <span class="number">1</span>;
}
</pre></td></tr></table></figure>


<p>实际上被解释成像下面那样：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> x;
    bar();
    x = <span class="number">1</span>;
}
</pre></td></tr></table></figure>


<p>结果是不管声明是否被执行都没有影响。下面的两段代码是等价的：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (<span class="literal">false</span>) {
        <span class="keyword">var</span> x = <span class="number">1</span>;
    }
    <span class="keyword">return</span>;
    <span class="keyword">var</span> y = <span class="number">1</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> x, y;
    <span class="keyword">if</span> (<span class="literal">false</span>) {
        x = <span class="number">1</span>;
    }
    <span class="keyword">return</span>;
    y = <span class="number">1</span>;
}
</pre></td></tr></table></figure>


<p>注意到声明的赋值部分并没有被提升(hoist)。只有声明的名称被提升了。这和函数声明不同，函数声明中，整个函数体也都会被提升。但是请记住，声明一个函数一般来说有两种方式。考虑下面的JavaScript代码：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> {</span>
    foo(); <span class="comment">// TypeError "foo is not a function"</span>
    bar(); <span class="comment">// "this will run!"</span>
    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="comment">// 函数表达式被赋值给变量'foo'</span>
        alert(<span class="string">"this won't run!"</span>);
    }
    <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> {</span> <span class="comment">// 名为'bar'的函数声明</span>
        alert(<span class="string">"this will run!"</span>);
    }
}
test();
</pre></td></tr></table></figure>


<p>在这里，只有函数声明的方式会连函数体一起提升，而函数表达式中只会提升名称，函数体只有在执行到赋值语句时才会被赋值。</p>
<p>以上就包括了所有关于提升(hoisting)的基础，看起来并没有那么复杂或是令人困惑对吧。但是，这是JavaScript，在某些特殊情况下，总会有那么一点复杂。</p>
<h2>Name Resolution Order</h2>
<p>需要记住的最最重要的特例就是名称解析顺序(name resolution order)。记住一个名称进入一个作用域一共有四种方式。我上面列出的顺序就是他们解析的顺序。总的来说，如果一个名称已经被定义了，他绝不会被另一个拥有不用属性的同名名称覆盖。这就意味着，函数声明比变量声明具有更高的优先级。但是这却不意味着对这个名称的赋值无效，仅仅是声明的部分会被忽略而已。但是有下面几个例外：</p>
<p>内置的名称arguments的行为有些怪异。他似乎是在形参之后，函数声明之前被声明。这就意味着名为arguments的形参会比内置的arguments具有更高的优先级，即使这个形参是undefined。这是一个不好的特性，不要使用arguments作为形参。
任何地方试图使用this作为一个标识都会引起语法错误，这是一个好的特性。
如果有多个同名形参，那位于列表最后的形参拥有最高的优先级，即使它是undefined。</p>
<h2>Name Function Expressions</h2>
<p>你可以在函数表达式中给函数定义名称，就像函数声明的语句一样。但这并不会使它成为一个函数声明，并且这个名称也不会被引入到作用域中，而且，函数体也不会被提升(hoist)。这里有一些代码可以说明我说的是什么意思：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>foo(); <span class="comment">// TypeError "foo is not a function"</span>
bar(); <span class="comment">// valid</span>
baz(); <span class="comment">// TypeError "baz is not a function"</span>
spam(); <span class="comment">// ReferenceError "spam is not defined"</span>

<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}; <span class="comment">// 匿名函数表达式('foo'被提升)</span>
<span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> {</span>}; <span class="comment">// 函数声明('bar'和函数体被提升)</span>
<span class="keyword">var</span> baz = <span class="function"><span class="keyword">function</span> <span class="title">spam</span><span class="params">()</span> {</span>}; <span class="comment">// 命名函数表达式(只有'baz'被提升)</span>

foo(); <span class="comment">// valid</span>
bar(); <span class="comment">// valid</span>
baz(); <span class="comment">// valid</span>
spam(); <span class="comment">// ReferenceError "spam is not defined"</span>
</pre></td></tr></table></figure>


<h2>How to Code With This Knowledge</h2>
<p>现在你明白了作用域和提升，那么这对编写JavaScript代码意味着什么呢？最重要的一条是声明变量时总是使用var语句。我强烈的建议你在每个作用域中都只在最顶端使用一个var。如果你强制自己这么做，你永远也不会被提升相关的问题困扰。尽管这么做会使的跟踪当前作用域实际声明了哪些变量变得更加困难。我建议在JSLint使用onevar选项。如果你做了所有前面的建议，你的代码看起来会是下面这样：</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/*jslint onevar: true [...] */</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a, b, c)</span> {</span>
    <span class="keyword">var</span> x = <span class="number">1</span>,
        bar,
        baz = <span class="string">"something"</span>;
}
</pre></td></tr></table></figure>


<p>What the Standard Says</p>
<p>我发现直接参考ECMAScript Standard (pdf)来理解这些东西是如何运作的总是很有用。下面是关于变量声明和作用域的一段摘录(section 12.2.2)：</p>
<blockquote><p>If the variable statement occurs inside a FunctionDeclaration, the variables are defined with function-local scope in that function, as described in section 10.1.3. Otherwise, they are defined with global scope (that is, they are created as members of the global object, as described in section 10.1.3) using property attributes { DontDelete }. Variables are created when the execution scope is entered. A Block does not define a new execution scope. Only Program and FunctionDeclaration produce a new scope. Variables are initialised to undefined when created. A variable with an Initialiser is assigned the value of its AssignmentExpression when the VariableStatement is executed, not when the variable is created.</p>
</blockquote>


<p>我希望这篇文章能够给JavaScript程序员最容易困惑的部分一些启示。我尽力写的全面，以免引起更多的困惑。如果我写错了或是漏掉了某些重要的东西，请一定让我知道。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2011-09-08T06:02:23.000Z"><a href="/2011/09/08/javascript中的“this”/">9月 8 2011</a></time>
      
      
  
    <h1 class="title"><a href="/2011/09/08/javascript中的“this”/">JavaScript中的“this”</a></h1>
  

    </header>
    <div class="entry">
      
        <p>JavaScript有自己的一套this机制，在不同情况下，this的指向也不尽相同。</p>
<h2>全局范围</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.log(<span class="keyword">this</span>); <span class="comment">//全局变量</span>
</pre></td></tr></table></figure>

<p>全局范围使用this指向的是全局变量，浏览器环境下就是window。</p>
<p>注：ECMAScript5的strict模式不存在全局变量，这里的this是undefined。</p>
<h2>函数调用中</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    console.log(<span class="keyword">this</span>);
}

foo(); <span class="comment">//全局变量</span>
</pre></td></tr></table></figure>

<p>函数调用中的this也指向全局变量。</p>
<p>注：ECMAScript5的strict模式不存在全局变量，这里的this是undefined。</p>
<h2>对象方法调用</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="keyword">var</span> test = {
    foo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        console.log(<span class="keyword">this</span>);
    }
}

test.foo(); <span class="comment">//test对象</span>
</pre></td></tr></table></figure>

<p>对象方法调用中，this指向调用者。</p>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> test = {
    foo: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        console.log(<span class="keyword">this</span>);
    }
}

<span class="keyword">var</span> test2 = test.foo;
test2();  <span class="comment">//全局变量</span>
</pre></td></tr></table></figure>

<p>不过由于this的晚绑定特性，在上例的情况中this将指向全局变量，相当于直接调用函数。</p>
<p>这点非常重要，同样的代码段，只有在运行时才能确定this指向</p>
<h2>构造函数</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span> {</span>
    console.log(<span class="keyword">this</span>);
}

<span class="keyword">new</span> Foo(); <span class="comment">//新创建的对象</span>
console.log(foo); 
</pre></td></tr></table></figure>

<p>在构造函数内部，this指向新创建的对象。</p>
<h2>显式设置this</h2>
<figure class="highlight lang-js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a, b)</span> {</span>
    console.log(<span class="keyword">this</span>);
}

<span class="keyword">var</span> bar = {};

foo.apply(bar, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">//bar</span>
foo.call(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//Number对象</span>
</pre></td></tr></table></figure>

<p>使用Function.prototype的call或者apply方法是，函数内部this会被设置为传入的第一个参数。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:betarabbit.github.io/">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>7</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2013 BetaRabbit
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'betarabbit';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>